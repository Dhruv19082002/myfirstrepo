install.packages("swirl")
install.packages("swirl")
git remote add origin https://github.com/Dhruv19082002/myfirstrepo.git
echo "# myfirstrepo" >> README.md
git init
echo "# myfirstrepo" >> README.md
echo "# myfirstrepo" >> README.md
echo "# myfirstrepo" >> README.md
git init
git remote add origin git@github.com:Dhruv19082002/myfirstrepo.git
library(swirl)
swirl()
my_vector <- 1:20
my_vector
dim(my_vector)
length(my_vector)
dim(my_vector) <- c(4,5)
dim(my_vector)
attributes(my_vector)
my_vector
class(my_vector)
my_matrix <- my_vector
?matrix()
matrix(my_matrix)
?matrix
my_matrix <- matrix(data= 1:20, nrow=4, ncol=5, byrow=False, dimnames = NULL)
skip()
idemtical(my_matrix,my_matrix2)
identical(my_matrix,my_matrix2)
skip()
cbind(patients)
cbind(patients, my_matrix)
my_data <- data.frame(patients,my_matrix)
my_data
class(my_data)
skip()
colnames(cnames)
colnames(my_data) <- cnames
my_data
Sys.Date()
mean <- argument c(2, 4, 5)
skip ()
submit()
x
skip()
boring_function('My first function!')
boring_function
skip()
my_mean()
mu_mean() <-c(4,5,10)
skip()
skip()
remainder(5)
remainder(11, 5)
remainder(divisor = 11, num = 5)
remainder (4, div=4)
remainder(4, div = 2)
args(remainder)
skip()
evaluate(c(1.4, 3.6, 7.9, 8.8))
skip ()
evaluate(function(x){x+1}, 6)
skip()
skip ()
?paste
paste("Programming", "is","fun!")
skip()
skip()
skip()
skip()
skip()
skip()
d1 <- Sys.Date()
class(d1)
unclass(d1)
d1
d2 <-Date("1969-01-01")
d2.Date("1969-01-01")
skip()
unclass(d2)
t1<-Sys.time()
t1
class(t1)
unclass(t1)
t2 <- as.POSIXlt(Sys.time())
t2
class(t2)
t2
unclass(t2)
str(unclass(t2))
t2$min
weekdays(d1)
months(t1)
quarters(t2)
skip()
strptime(t3, "%B %d, %Y %H:%M")
t4 <- strptime(t3, "%B %d, %Y %H:%M")
t4
class(t4)
Sys.time() > t1
Sys.time() - t1
difftime(Sys.time(), t1, units = 'days')
skip()
skip()
pollution$pm25
summary(pollution$pm25)
skip()
skip()
skip()
skip()
skip()
skip()
10
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
?Devices
skip()
skip()
dev.cur()
pdf(file="myplot.pdf")
pdf(file="myplot.pdf")
with(faithful, plot(eruptions, waiting))
skip()
skip()
dev.off()
dev.cur()
skip()
skip()
skip()
dev.off()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
par("lty")
par("lty")
plot(airquality$Wind, type="n",airquality$Ozone)
plot(airquality$Wind, type="n",airquality$Ozone)
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
skip()
library(swirl)
siwrl()
swirl()
skip()
skip()
x0 <- pm0$Sample.Value
x0 <- pm0$Sample.Value
x0 <- pm0$Sample.Value
x0 <- pm0$Sample.Value
x0 <- pm0$Sample.Value
x0 <- pm0$Sample.Value
x0 <- pm0$Sample.Value
x0 <- pm0$Sample.Value
x0 <- pm0$Sample.Value
x0 <- pm0$Sample.Value
x0 <- pm0$Sample.Valuex0 <- pm0$Sample.Value
info()
x0 <- pm0$smaple.value
x0 <- pm0$Sample.Value
main()
x0<-pm0
x0<- pm0$1304287
x0 <- pm0$sample.value
x0 <- pm0$Sample.Value
x0 <- pm0$Sample.Value
main()
library(swirl)
#install_from_swirl("Exploratory Data Analysis")
library(ggplot2)
library(jpeg)
library(swirl)
library(Swirl)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
makeVector <- function(x = numeric())
makeCacheMatrix <- function(x = matrix()) {
makeCacheMatrix <- function(x = matrix())
makecachematrix <-`function(x=matrix())
install.packages("Matrix")
makeCacheMatrix <- function( m = matrix() )
makeCacheMatrix <- function( m = matrix() ) {
set <- function( matrix ) {
m <<- matrix
i <<- NULL
}
get <- function() {m}
setInverse <- function(inverse) {
i <<- inverse
}
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
getInverse <- function() {
i
}
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getInverse()
## Just return the inverse if its already set
if( !is.null(m) ) {
message("getting cached data")
return(m)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getInverse()
## Just return the inverse if its already set
if( !is.null(m) ) {
message("getting cached data")
return(m)
}
makeCacheMatrix <- function( m = matrix() ) {
i <- NULL
set <- function( matrix ) {
m <<- matrix
i <<- NULL
}
get <- function() {
View(getInverse)
makeCacheMatrix <- function( m = matrix() ) {
i <- NULL
set <- function( matrix ) {
m <<- matrix
i <<- NULL
}
makeCacheMatrix <- function( m = matrix() ) {
## Initialize the inverse property
i <- NULL
## Method to set the matrix
set <- function( matrix ) {
m <<- matrix
i <<- NULL
}
makeCacheMatrix <- function( m = matrix() )
makeCacheMatric <- function( m=matrix())
{}
makeCacheMatrix <- function( m = matrix() ) {
makeCacheMatrix <- function( m = matrix()){i<- NULL}
makeCacheMatrix <- function( m = matrix()){ i <- NULL set <- function( matrix )m <<- matrix
## A pair of functions that cache the inverse of a matrix
## Creates a special matrix object that can cache its inverse
makeCacheMatrix <- function( m = matrix() ) {
## Initialize the inverse property
i <- NULL
## Method to set the matrix
set <- function( matrix ) {
m <<- matrix
i <<- NULL
}
## Method the get the matrix
get <- function() {
## Return the matrix
m
}
## Method to set the inverse of the matrix
setInverse <- function(inverse) {
i <<- inverse
}
## Method to get the inverse of the matrix
getInverse <- function() {
## Return the inverse property
i
}
## Return a list of the methods
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## Compute the inverse of the special matrix returned by "makeCacheMatrix"
## above. If the inverse has already been calculated (and the matrix has not
## changed), then the "cachesolve" should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getInverse()
## Just return the inverse if its already set
if( !is.null(m) ) {
message("getting cached data")
return(m)
}
## Get the matrix from our object
data <- x$get()
## Calculate the inverse using matrix multiplication
m <- solve(data) %*% data
## Set the inverse to the object
x$setInverse(m)
## Return the matrix
m
}
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function1
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y){
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(solveMatrix) inv <<- solveMatrix
getInverse <- function() inv
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if(!is.null(inv)){
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setInverse(inv)
inv
}
